# 2020 Code Review Party - Team 4183 Feedback

Hi Team 687, thank you for sharing your code with our team. Three of our software students and our software mentor all cloned your codebase, reviewed the code, and discussed it as a team to come up with this feedback. We approached the codebase as if we were new students on your team trying to understand how the code works.

## Overall Thoughts

The codebase is quite large and complex. There is a lot of great code and it is very well structured. Just by reading class names and packages we could get a sense of what the robot is supposed to do. We had a bit of a tough time determining specifics of what a subsystem did because of the level of abstraction in NerdyLib. There was also a lot of unused and uncommented code in NerdyLib which made it hard to figure out what we should focus on.

## Things we Liked

- **Command based everything** - We have only used command base programming for part of our robot. It was neat to see an entire codebase where everything had a command.
- **Logging** - We liked the extensive use of logging and logging with lambdas. It was great to see a standard for logging being used throughout the project.
- **ParallelRaceGroup in Auto** - Using a parallel race group for stopping the intake motor after the trajectory is complete is a very elegant solution.
- **State Space** - We have been working towards adding state space control to our robot, so it was great to see another team with code for it.
- **Auto Trajectory Classes** - Having different classes for each auto trajectory made it very easy to understand what each trajectory was supposed to do.
- **Ether Joystick Sensitivity** - The Ether joystick sensitivty code was very neat!

## Things to Improve

### NerdyLib Abstraction

- [ ] As a new reader, NerdyLib contained many layers of abstraction that made it very hard to follow. The Hood was a subsystem with a single motor, but the chain of inheritance looked like this:

`Hood -> SingleMotorArm -> GravityAffectedMechanism -> StaticFrictionMechanism -> SingleMotorMechanism -> SingleMotorMechanism -> SmartMotorControllerSubsystem -> AbstractSingleMotor -> SusbsystemBase`

Each of these classes defined a small piece of functionality and it was difficult to figure out exactly what the Hood class did. We weren't even sure it was a WPI Subsystem until we followed the code 7 classes down the chain. For new students or for students coming from different teams, this abstraction would make it difficult to understand the "whole picture" of what a class does.

If the Hood is managing a single motor, it would be clearer to configure and operate the motor within the Hood class, even if it means some duplicate code in other single motor classes. If you want to reduce boilerplate, perhaps you could use utility functions to configure the motor with the arguments you need for each type of functionality?

For example, these super.\* methods in the Hood class could be part of a MotorConfigurer() class, instead of part of the Hood inheritance:

```java
  public Hood() {
    super(RobotMap.kHoodID, "Hood", false, false);

    MotorConfigurer motorConfigurer = new MotorConfigurer(this.motor);
    motorConfigurer.configAngleConversion(HoodConstants.kHoodAngleRatio, HoodConstants.kHoodAngleOffset);
    motorConfigurer.configTrapezoidalConstraints(new TrapezoidProfile.Constraints(HoodConstants.kHoodVel, HoodConstants.kHoodAccel));
    motorConfigurer.configPIDF(HoodConstants.kHoodP, 0, 0, HoodConstants.kHoodF);
    motorConfigurer.configFFs(HoodConstants.kHoodGravityFF, HoodConstants.kHoodStaticFriction);
    motorConfigurer.configOblargConstants(HoodConstants.kHoodS, HoodConstants.kHoodCos, HoodConstants.kHoodV, HoodConstants.kHoodA);
    motorConfigurer.configMotionMagic(HoodConstants.kMotionMagicAcceleration, HoodConstants.kMotionMagicVelocity);
    motorConfigurer.configDeadband(0.0004);
    motorConfigurer.setCoastMode();
  }
```

This way, rather than looking through a bunch of classes to figure out how this motor is configured, you can look in one place.

#### Other NerdyLib Suggestions

- [ ] A README with a diagram showing the various classes and what they are for would be a great step towards helping the code be more understandable.
- [ ] A comment above each subsystem to describe how it worked would be helpful

### Magic Numbers

- [ ] The Hood class uses magic numbers instead of constants to change behavior based on distance
- [ ] OJ.java should use joystick constants instead of numbers. It's tough to tell what buttons map up to which commands.

### distance vs distanceWidth

- [ ] We had to ask what distanceWidth was. distance is not used at all. It would be clearer to remove the distance variable and rename distanceWidth to distance.

### Odometry

- [ ] WPI has a built in characterization and odometry library. You should switch to using that rather than rolling your own, unless you have a use case they don't cover.

### Shooter Distance Approximation

- [ ] For the shooter distance to speed approximation, a spline is probably more accurate.

### Miscellaneous

- [ ] OI.java has large swaths of code that is commented out. Is this code necessary? Can it be removed? There is no comment saying "This code will go back in when debugging" or anything like that.
- [ ] OI.java could use commented sections to better separate functionality. For example:

```java

//
// Driver Controls
//
shiftHigh_6L = new JoystickButton(super.driveJoyLeft, 6);
shiftLow_6R = new JoystickButton(super.driveJoyRight, 6);
turnToAngle_1L = new JoystickButton(super.driveJoyLeft, 1);
turnToAngle_1R = new JoystickButton(super.driveJoyRight, 1);

//
// Intake Controls
//
ploughIntake_2 = new JoystickButton(super.driveJoyLeft, 2); // Check in with Drivers
intake_1 = new JoystickButton(super.operatorJoy, 1);

//
// Climb Controls
//
climbReady_3L = new JoystickButton(super.driveJoyLeft, 3);
climbLift_4L = new JoystickButton(super.driveJoyLeft, 4);

```

This way you can easily find the functionality you are looking for.

- [ ] There is a lot of unused code in the robot that should probably be moved to NerdyLib rather than left in the main robot. It's a large code base and only made more complicated by sifting through unused classes.
- [ ] Voltage Compensation should be less than 12V

## Summary

Thank you for giving us the opportunity to see your code. It was very informative to see how your team coded a robot. We learned a lot from it and we hope our feedback is helpful to you in your future robot coding. Good luck in the rest of the season!
